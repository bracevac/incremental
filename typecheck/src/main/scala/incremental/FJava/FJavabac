package incremental.FJava

import constraints.{CVar, Statistics}
import constraints.equality._
import incremental.{Node_, Util}
import incremental.Node._

/**
 * Created by lirakuci on 3/2/15.
 */


class Class(val name: Symbol, superClass: Symbol, val fields: List[Fields], val m: List[Methods])

class Fields(fname: Symbol, val fType: Type)

class Methods(val mtype: Symbol, mparam: List[(Symbol,Type)], mreturnT : Type)
{
  val param = this.mparam
}

class ClassDecl(cName: Type , cSuper: Type, cFld: List[Fields], cMethods: List[Methods])
{
  val c = this.cName
  val s = this.cSuper
  val f = this.cFld
  val m = this.cMethods
}
abstract class BUChecker[CS <: ConstraintSystem[CS]] extends TypeChecker[CS] {

  import csFactory._

  type TError = String

  type Name = String
  type Parameter = Name
  type Assignment = (Name, Name)

  type Reqs = Map[Symbol, Type]

  type CReqs = Map[Type, ClassDecl]

  val ct = new ClassDecl(null, null, List(), List())

  def Subtype(C: Type, D: Type): CReqs = {
    val cld = new ClassDecl(C, D, List(), List())
    Map(C -> cld)
  }


  type StepResult = (Type, Reqs, CReqs, Seq[Constraint])
  type Result = (Type, Reqs, CReqs, CS)

  def typecheckImpl(e: Node): Either[Type, TError] = {
    val root = e.withType[Result]

    Util.timed(localState -> Statistics.typecheckTime) {
      root.visitUninitialized {e =>
        val (t, reqs, treqs, cons) = typecheckStep(e)
        val subcs = e.kids.seq.foldLeft(freshConstraintSystem)((cs, res) => cs mergeSubsystem res.typ._4)
        val cs = subcs addNewConstraints cons
        val reqs2 = cs.applyPartialSolutionIt[(Symbol,Type),Map[Symbol,Type],Type](reqs, p => p._2)
        e.typ = (cs applyPartialSolution t, reqs2, treqs, cs.propagate)
        true
      }

      val (t_, reqs, creqs, cs_) = root.typ
      val cs = cs_.tryFinalize
      val t = t_.subst(cs.substitution)

      if (!reqs.isEmpty)
        Right(s"Unresolved variable requirements $reqs, type $t, unres ${cs.unsolved}")
      else if (!creqs.isEmpty)
        Right(s"Unresolved type-variable requirements $creqs, type $t, unres ${cs.unsolved}")
      else if (!cs.isSolved)
        Right(s"Unresolved constraints ${cs.unsolved}, type $t")
      else
        Left(t)
    }
  }


  def typecheckStep(e: Node_[Result]): StepResult = e.kind match{

    case Var =>
      val x = e.lits(0).asInstanceOf[Symbol]
      val X = freshUVar()
      (X, Map(x -> X), Map(), Seq())

    case Field =>
      val f = e.lits(0).asInstanceOf[Symbol] //symbol
      val (t, reqs, creqs, _) = e.kids(0).typ //subsol
      //t.unify(e0)
      val U = freshCName()
      val fld = new Fields(f, U) //symbol
      val ct = new ClassDecl(t, null, List(fld), List())
      (U, reqs, creqs + (t -> ct), Seq())//subsol

    case Invk =>
      if (e.kids.seq.size == 1 ) {
        val m = e.lits(0).asInstanceOf[Symbol]
        val (e0, reqs1, creqs1, _) = e.kids(0).typ //subsol1
        val C = freshCName()
        val method = new Methods(m, List(), C)
        val cld = new ClassDecl(e0, null, List(), List(method))
        (C, reqs1, creqs1 + (e0 -> cld), Seq()) //subsol1

      }
      else {
        val m = e.lits(0).asInstanceOf[Symbol]
        val C = freshCName()
       // var mcons = Seq[Constraint]()
        var mreqs: Reqs = Map()
        var mcreqs: CReqs = Map()
        var param =  List[(Symbol,Type)]()
        var method = new Methods(m, param, C)
      //  var msol = emptySol
        val (e0, reqs1, creqs1, _) = e.kids(0).typ
        val subs = for (sub <- e.kids.seq drop(0)) yield {
          val (ei, subreqs, subcreqs, _) = sub.typ

          //val (cons, reqs) = mergeReqMaps(subreqs)
          val di = freshUVar()
           Subtype(ei, di)
          mreqs = mreqs ++ subreqs
          mcreqs = mcreqs ++ subcreqs ++ Subtype(ei, di)
          param ++= List((di.x, ei))
        }
        val (cons, reqs) = mergeReqMaps(mreqs)
        val (cCons, creqs) = mergeCReqMaps(mcreqs)

        val cld = new ClassDecl(e0, null, List(), List(method))
        (C, mreqs ++ reqs1 ,mcreqs ++ creqs1 + (e0 -> cld) , cons ++ cCons)

      }


    case New =>
      val c = e.lits(0).asInstanceOf[CName]
      if (e.kids.seq == Seq()) {
        val cld = new ClassDecl(c, null, List(), List())
        (c, Map(), Map(c -> cld), Seq())
      }
      else {
          val U = freshCName()
          var mcons = Seq[Constraint]()
          var mreqs: Reqs = Map()
          var mcreqs: CReqs = Map()
          var field = List[Fields]()
          val subs = for (sub <- e.kids.seq) yield {
            val (ei, subreqs, subcreqs, subsol) = sub.typ
            val di = freshUVar()
            mreqs = mreqs ++ subreqs
            mcreqs = mcreqs ++ subcreqs ++ Subtype(ei,di)
            val fld = new Fields(di.x.x, di)
            field ++= List(fld)
          }
          val (cons, reqs) = mergeReqMaps(mreqs)
          val (cCons, creqs ) = mergeCReqMaps(mcreqs)

          val cld = new ClassDecl(c, null, field, List())
          (c, reqs ,creqs + (c -> cld), cons ++ cCons)
      }

     // val (t, reqs, creqs, subsol) = e.kids(0).typ
     // val f = U.x
     // val fld = new Fields(f, U)
     // val cld = new ClassDecl(c, null, List(fld), List())
     // (c, reqs, creqs + (c -> cld) ++ Subtype(t, U), subsol)
     // }

    case DCast =>
      val (t, reqs, creqs, _) = e.kids(0).typ
      val c = e.lits(0).asInstanceOf[CName]

      (c, reqs, creqs ++ Subtype(c, c), Seq((NotEqConstraint(t, c))))

    case UCast =>
      val c = e.lits(0).asInstanceOf[CName]
      val (t, reqs, creqs,_) = e.kids(0).typ

      (c, reqs, creqs ++ Subtype(t, c), Seq())

    case SCast =>
      val (t, reqs, creqs, _) = e.kids(0).typ
      (t, reqs, creqs, Seq())

    case Method =>
      val lits = e.lits.asInstanceOf[Seq[Symbol]]
      var param = List[(Symbol, Type)]()
      val (e0, reqs, creqs, subsol) = e.kids(0).typ
      val C = e.lits(0).asInstanceOf[CName]
      val C0 = e.lits(1).asInstanceOf[CName]
      val m = e.lits(2).asInstanceOf[Symbol]
      var restReqs = reqs
      var cons = Seq[Constraint]
      for (i <- 2 until e.lits.seq.size) {
        val x = e.lits.seq(i).asInstanceOf[Symbol]
        // val params = for ( lst <- seqK.sliding(2,2) ) yield {
        //  val first = lst.head
        //  val second = lst.tail.head
        //  val x = first.asInstanceOf[Symbol]
        //  val t = second.asInstanceOf[CName]
        // val (t, subreqs, subcreqs, subsol) = second.typ
        //(first.asInstanceOf[Symbol], second.typ)

        //params.toSeq.head._2
        //params.toSeq.head._1

        restReqs.get(x) match {
          case None =>
            val xC = if (e.lits.seq(i + 1).isInstanceOf[Type]) e.lits(i + 1).asInstanceOf[Type] else freshUVar()
            param ++= List((x, xC))
          case Some(treq) =>
            val restReqs = reqs - x
            val xC = e.lits(i + 1).asInstanceOf[Type]
            param ++= List((x,xC))
            cons = EqConstraint(xC, treq) +: cons
        }
      }
      val method = new Methods(m, param , C)
      val cld = new ClassDecl(C, null, List(), List(method))
      (C0, restReqs, creqs ++ Subtype(e0, C0) + (C -> cld), cons)

    case TClass =>
      val (t, reqs, creqs, _) = e.kids(0).typ
      (t, reqs, creqs, Seq())


  }
  private val init: (Seq[Constraint], Reqs) = (Seq(), Map())

  def mergeReqMaps(req: Reqs, reqs: Reqs*): (Seq[Constraint], Reqs) = mergeReqMaps(req +: reqs)

  def mergeReqMaps(reqs: Seq[Reqs]): (Seq[Constraint], Reqs) =
    Util.timed(localState -> Statistics.mergeReqsTime) {
      reqs.foldLeft[(Seq[Constraint], Reqs)](init)(_mergeReqMaps)
    }

  private def _mergeReqMaps(was: (Seq[Constraint], Reqs), newReqs: Reqs) = {
    val wasReqs = was._2
    var mcons = was._1
    var mreqs = wasReqs
    for ((x, r2) <- newReqs)
      wasReqs.get(x) match {
        case None => mreqs += x -> r2
        case Some(r1) =>
          mcons = EqConstraint(r1, r2) +: mcons
      }
    (mcons, mreqs)
  }
  private val cinit: (Seq[Constraint], CReqs) = (Seq(), Map())

  def mergeCld(cld1: ClassDecl, cld2 : ClassDecl) : ClassDecl = {
    val f = cld1.f ++ cld2.f
    val m = cld1.m ++ cld2.m
    cld1
  }
  def mergeCReqMaps(req: CReqs, reqs: CReqs*): (Seq[Constraint], CReqs) = mergeCReqMaps(req +: reqs)

  def mergeCReqMaps(reqs: Seq[CReqs]): (Seq[Constraint], CReqs) =
    Util.timed(localState -> Statistics.mergeReqsTime) {
      reqs.foldLeft[(Seq[Constraint], CReqs)](cinit)(_mergeCReqMaps)
   }


  private def _mergeCReqMaps(creqs1: (Seq[Constraint], CReqs), creqs2: CReqs) = {
    var mcons = creqs1._1
    var mreqs = creqs1._2
    for ((t, cld2) <- creqs2)
      creqs1._2.get(t) match {
        case None => creqs2
        case Some(cld1) => mreqs += t -> mergeCld(cld1,cld2)
        // mcons =EqConstraint(cld1.c, cld2.c) +: mcons
      }
    (mcons, mreqs)
  }
}


case class BUCheckerFactory[CS <: ConstraintSystem[CS]](factory: ConstraintSystemFactory[CS]) extends TypeCheckerFactory[CS] {
  def makeChecker = new BUChecker[CS] {
    type CSFactory = factory.type
    implicit val csFactory: CSFactory = factory
  }
}
